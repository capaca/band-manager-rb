    <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
    <html lang='en' xml:lang='en' xmlns='http://www.w3.org/1999/xhtml'>
      <head>
        <title>lib/xspf.rb - C0 code coverage information</title>
        <style type='text/css'>body { background-color: rgb(240, 240, 245); }</style>
        <style type='text/css'>span.cross-ref-title {
 font-size: 140%;
}
span.cross-ref a {
 text-decoration: none;
}
span.cross-ref {
 background-color:#f3f7fa;
 border: 1px dashed #333;
 margin: 1em;
 padding: 0.5em;
 overflow: hidden;
}
a.crossref-toggle {
 text-decoration: none;
}
span.marked0 {
 background-color: rgb(185, 210, 200);
 display: block;
}
span.marked1 {
 background-color: rgb(190, 215, 205);
 display: block;
}
span.inferred0 {
 background-color: rgb(175, 200, 200);
 display: block;
}
span.inferred1 {
 background-color: rgb(180, 205, 205);
 display: block;
}
span.uncovered0 {
 background-color: rgb(225, 110, 110);
 display: block;
}
span.uncovered1 {
 background-color: rgb(235, 120, 120);
 display: block;
}
span.overview {
 border-bottom: 8px solid black;
}
div.overview {
 border-bottom: 8px solid black;
}
body {
 font-family: verdana, arial, helvetica;
}
div.footer {
 font-size: 68%;
 margin-top: 1.5em;
}
h1, h2, h3, h4, h5, h6 {
 margin-bottom: 0.5em;
}
h5 {
 margin-top: 0.5em;
}
.hidden {
 display: none;
}
div.separator {
 height: 10px;
}
/* Commented out for better readability, esp. on IE */
/*
table tr td, table tr th {
 font-size: 68%;
}
td.value table tr td {
 font-size: 11px;
}
*/
table.percent_graph {
 height: 12px;
 border: #808080 1px solid;
 empty-cells: show;
}
table.percent_graph td.covered {
 height: 10px;
 background: #00f000;
}
table.percent_graph td.uncovered {
 height: 10px;
 background: #e00000;
}
table.percent_graph td.NA {
 height: 10px;
 background: #eaeaea;
}
table.report {
 border-collapse: collapse;
 width: 100%;
}
table.report td.heading {
 background: #dcecff;
 border: #d0d0d0 1px solid;
 font-weight: bold;
 text-align: center;
}
table.report td.heading:hover {
 background: #c0ffc0;
}
table.report td.text {
 border: #d0d0d0 1px solid;
}
table.report td.value,
table.report td.lines_total,
table.report td.lines_code {
 text-align: right;
 border: #d0d0d0 1px solid;
}
table.report tr.light {
 background-color: rgb(240, 240, 245);
}
table.report tr.dark {
 background-color: rgb(230, 230, 235);
}
</style>
        <script type='text/javascript'>
// <![CDATA[
  function toggleCode( id ) {
    if ( document.getElementById )
      elem = document.getElementById( id );
    else if ( document.all )
      elem = eval( "document.all." + id );
    else
      return false;

    elemStyle = elem.style;
    
    if ( elemStyle.display != "block" ) {
      elemStyle.display = "block"
    } else {
      elemStyle.display = "none"
    }

    return true;
  }
  
  // Make cross-references hidden by default
  document.writeln( "<style type=\"text/css\">span.cross-ref { display: none }</style>" )
  // ]]>
</script>
        <style type='text/css'>span.run0 {
  background-color: rgb(178, 204, 255);
  display: block;
}
span.run1 {
  background-color: rgb(178, 206, 255);
  display: block;
}
span.run2 {
  background-color: rgb(178, 209, 255);
  display: block;
}
span.run3 {
  background-color: rgb(178, 211, 255);
  display: block;
}
span.run4 {
  background-color: rgb(178, 214, 255);
  display: block;
}
span.run5 {
  background-color: rgb(178, 218, 255);
  display: block;
}
span.run6 {
  background-color: rgb(178, 220, 255);
  display: block;
}
span.run7 {
  background-color: rgb(178, 223, 255);
  display: block;
}
span.run8 {
  background-color: rgb(178, 225, 255);
  display: block;
}
span.run9 {
  background-color: rgb(178, 228, 255);
  display: block;
}
span.run10 {
  background-color: rgb(178, 232, 255);
  display: block;
}
span.run11 {
  background-color: rgb(178, 234, 255);
  display: block;
}
span.run12 {
  background-color: rgb(178, 237, 255);
  display: block;
}
span.run13 {
  background-color: rgb(178, 239, 255);
  display: block;
}
span.run14 {
  background-color: rgb(178, 242, 255);
  display: block;
}
span.run15 {
  background-color: rgb(178, 246, 255);
  display: block;
}
span.run16 {
  background-color: rgb(178, 248, 255);
  display: block;
}
span.run17 {
  background-color: rgb(178, 251, 255);
  display: block;
}
span.run18 {
  background-color: rgb(178, 253, 255);
  display: block;
}
span.run19 {
  background-color: rgb(178, 255, 253);
  display: block;
}
span.run20 {
  background-color: rgb(178, 255, 249);
  display: block;
}
span.run21 {
  background-color: rgb(178, 255, 247);
  display: block;
}
span.run22 {
  background-color: rgb(178, 255, 244);
  display: block;
}
span.run23 {
  background-color: rgb(178, 255, 242);
  display: block;
}
span.run24 {
  background-color: rgb(178, 255, 239);
  display: block;
}
span.run25 {
  background-color: rgb(178, 255, 235);
  display: block;
}
span.run26 {
  background-color: rgb(178, 255, 233);
  display: block;
}
span.run27 {
  background-color: rgb(178, 255, 230);
  display: block;
}
span.run28 {
  background-color: rgb(178, 255, 228);
  display: block;
}
span.run29 {
  background-color: rgb(178, 255, 225);
  display: block;
}
span.run30 {
  background-color: rgb(178, 255, 221);
  display: block;
}
span.run31 {
  background-color: rgb(178, 255, 219);
  display: block;
}
span.run32 {
  background-color: rgb(178, 255, 216);
  display: block;
}
span.run33 {
  background-color: rgb(178, 255, 214);
  display: block;
}
span.run34 {
  background-color: rgb(178, 255, 211);
  display: block;
}
span.run35 {
  background-color: rgb(178, 255, 207);
  display: block;
}
span.run36 {
  background-color: rgb(178, 255, 205);
  display: block;
}
span.run37 {
  background-color: rgb(178, 255, 202);
  display: block;
}
span.run38 {
  background-color: rgb(178, 255, 200);
  display: block;
}
span.run39 {
  background-color: rgb(178, 255, 197);
  display: block;
}
span.run40 {
  background-color: rgb(178, 255, 193);
  display: block;
}
span.run41 {
  background-color: rgb(178, 255, 191);
  display: block;
}
span.run42 {
  background-color: rgb(178, 255, 188);
  display: block;
}
span.run43 {
  background-color: rgb(178, 255, 186);
  display: block;
}
span.run44 {
  background-color: rgb(178, 255, 183);
  display: block;
}
span.run45 {
  background-color: rgb(178, 255, 179);
  display: block;
}
span.run46 {
  background-color: rgb(179, 255, 178);
  display: block;
}
span.run47 {
  background-color: rgb(182, 255, 178);
  display: block;
}
span.run48 {
  background-color: rgb(184, 255, 178);
  display: block;
}
span.run49 {
  background-color: rgb(187, 255, 178);
  display: block;
}
span.run50 {
  background-color: rgb(191, 255, 178);
  display: block;
}
span.run51 {
  background-color: rgb(193, 255, 178);
  display: block;
}
span.run52 {
  background-color: rgb(196, 255, 178);
  display: block;
}
span.run53 {
  background-color: rgb(198, 255, 178);
  display: block;
}
span.run54 {
  background-color: rgb(201, 255, 178);
  display: block;
}
span.run55 {
  background-color: rgb(205, 255, 178);
  display: block;
}
span.run56 {
  background-color: rgb(207, 255, 178);
  display: block;
}
span.run57 {
  background-color: rgb(210, 255, 178);
  display: block;
}
span.run58 {
  background-color: rgb(212, 255, 178);
  display: block;
}
span.run59 {
  background-color: rgb(215, 255, 178);
  display: block;
}
span.run60 {
  background-color: rgb(219, 255, 178);
  display: block;
}
span.run61 {
  background-color: rgb(221, 255, 178);
  display: block;
}
span.run62 {
  background-color: rgb(224, 255, 178);
  display: block;
}
span.run63 {
  background-color: rgb(226, 255, 178);
  display: block;
}
span.run64 {
  background-color: rgb(229, 255, 178);
  display: block;
}
span.run65 {
  background-color: rgb(233, 255, 178);
  display: block;
}
span.run66 {
  background-color: rgb(235, 255, 178);
  display: block;
}
span.run67 {
  background-color: rgb(238, 255, 178);
  display: block;
}
span.run68 {
  background-color: rgb(240, 255, 178);
  display: block;
}
span.run69 {
  background-color: rgb(243, 255, 178);
  display: block;
}
span.run70 {
  background-color: rgb(247, 255, 178);
  display: block;
}
span.run71 {
  background-color: rgb(249, 255, 178);
  display: block;
}
span.run72 {
  background-color: rgb(252, 255, 178);
  display: block;
}
span.run73 {
  background-color: rgb(255, 255, 178);
  display: block;
}
span.run74 {
  background-color: rgb(255, 252, 178);
  display: block;
}
span.run75 {
  background-color: rgb(255, 248, 178);
  display: block;
}
span.run76 {
  background-color: rgb(255, 246, 178);
  display: block;
}
span.run77 {
  background-color: rgb(255, 243, 178);
  display: block;
}
span.run78 {
  background-color: rgb(255, 240, 178);
  display: block;
}
span.run79 {
  background-color: rgb(255, 238, 178);
  display: block;
}
span.run80 {
  background-color: rgb(255, 234, 178);
  display: block;
}
span.run81 {
  background-color: rgb(255, 232, 178);
  display: block;
}
span.run82 {
  background-color: rgb(255, 229, 178);
  display: block;
}
span.run83 {
  background-color: rgb(255, 226, 178);
  display: block;
}
span.run84 {
  background-color: rgb(255, 224, 178);
  display: block;
}
span.run85 {
  background-color: rgb(255, 220, 178);
  display: block;
}
span.run86 {
  background-color: rgb(255, 218, 178);
  display: block;
}
span.run87 {
  background-color: rgb(255, 215, 178);
  display: block;
}
span.run88 {
  background-color: rgb(255, 212, 178);
  display: block;
}
span.run89 {
  background-color: rgb(255, 210, 178);
  display: block;
}
span.run90 {
  background-color: rgb(255, 206, 178);
  display: block;
}
span.run91 {
  background-color: rgb(255, 204, 178);
  display: block;
}
span.run92 {
  background-color: rgb(255, 201, 178);
  display: block;
}
span.run93 {
  background-color: rgb(255, 198, 178);
  display: block;
}
span.run94 {
  background-color: rgb(255, 196, 178);
  display: block;
}
span.run95 {
  background-color: rgb(255, 192, 178);
  display: block;
}
span.run96 {
  background-color: rgb(255, 189, 178);
  display: block;
}
span.run97 {
  background-color: rgb(255, 187, 178);
  display: block;
}
span.run98 {
  background-color: rgb(255, 184, 178);
  display: block;
}
span.run99 {
  background-color: rgb(255, 182, 178);
  display: block;
}
span.run100 {
  background-color: rgb(255, 178, 178);
  display: block;
}
</style>
      </head>
      <body>
        <h3>C0 code coverage information</h3>
        <p>Generated on Tue Apr 10 20:52:45 +0200 2007 with <a href='http://eigenclass.org/hiki.rb?rcov'>rcov 0.8.0</a>
        </p>
        <hr /><pre><span class='marked0'>Code reported as executed by Ruby looks like this...
</span><span class='marked1'>and this: this line is also marked as covered.
</span><span class='inferred0'>Lines considered as run by rcov, but not reported by Ruby, look like this,
</span><span class='inferred1'>and this: these lines were inferred by rcov (using simple heuristics).
</span><span class='uncovered0'>Finally, here&apos;s a line marked as not executed.
</span></pre>                       
    <table class='report'>
      <thead>
        <tr>
          <td class='heading'>Name</td>
          <td class='heading'>Total lines</td>
          <td class='heading'>Lines of code</td>
          <td class='heading'>Total coverage</td>
          <td class='heading'>Code coverage</td>
        </tr>
      </thead>
      <tbody>
        <tr class='light'>
          <td>
            <a href='lib-xspf_rb.html'>lib/xspf.rb</a>
          </td>
          <td class='lines_total'>
            <tt>491</tt>
          </td>
          <td class='lines_code'>
            <tt>331</tt>
          </td>
          <td>
            <table cellspacing='0' cellpadding='0' align='right'>
              <tr>
                <td>
                  <tt class='coverage_total'>98.4%</tt>&nbsp;</td>
                <td>
                  <table cellspacing='0' class='percent_graph' cellpadding='0' width='100'>
                    <tr>
                      <td class='covered' width='98' />
                      <td class='uncovered' width='2' />
                    </tr>
                  </table>
                </td>
              </tr>
            </table>
          </td>
          <td>
            <table cellspacing='0' cellpadding='0' align='right'>
              <tr>
                <td>
                  <tt class='coverage_code'>97.6%</tt>&nbsp;</td>
                <td>
                  <table cellspacing='0' class='percent_graph' cellpadding='0' width='100'>
                    <tr>
                      <td class='covered' width='98' />
                      <td class='uncovered' width='2' />
                    </tr>
                  </table>
                </td>
              </tr>
            </table>
          </td>
        </tr>
      </tbody>
    </table><pre><span class="inferred1"><a name="line1" />  1 #--
</span><span class="inferred0"><a name="line2" />  2 # =============================================================================
</span><span class="inferred1"><a name="line3" />  3 # Copyright (c) 2006 Pau Garcia i Quiles (pgquiles@elpauer.org)
</span><span class="inferred0"><a name="line4" />  4 # All rights reserved.
</span><span class="inferred1"><a name="line5" />  5 #
</span><span class="inferred0"><a name="line6" />  6 # This library may be used only as allowed by either the Ruby license (or, by
</span><span class="inferred1"><a name="line7" />  7 # association with the Ruby license, the GPL). See the &quot;doc&quot; subdirectory of
</span><span class="inferred0"><a name="line8" />  8 # the XSPF distribution for the texts of these licenses.
</span><span class="inferred1"><a name="line9" />  9 # -----------------------------------------------------------------------------
</span><span class="inferred0"><a name="line10" /> 10 # XSPF for Ruby website : http://xspf.rubyforge.org
</span><span class="inferred1"><a name="line11" /> 11 # =============================================================================
</span><span class="inferred0"><a name="line12" /> 12 #++
</span><span class="inferred1"><a name="line13" /> 13 
</span><span class="marked0"><a name="line14" /> 14 require 'rexml/document'
</span><span class="inferred1"><a name="line15" /> 15 
</span><span class="marked0"><a name="line16" /> 16 begin
</span><span class="marked1"><a name="line17" /> 17   require 'xml/xslt_lib' # For ruby-xslt 0.9.3 or newer
</span><span class="uncovered0"><a name="line18" /> 18 rescue LoadError =&gt; e
</span><span class="uncovered1"><a name="line19" /> 19   begin
</span><span class="uncovered0"><a name="line20" /> 20     require 'xml/xslt' # For ruby-xslt 0.9.2 or older
</span><span class="uncovered1"><a name="line21" /> 21   rescue LoadError =&gt; e
</span><span class="uncovered0"><a name="line22" /> 22     puts &quot;You need to install ruby-xslt to use ruby-xspf&quot;
</span><span class="uncovered1"><a name="line23" /> 23     exit
</span><span class="uncovered0"><a name="line24" /> 24   end
</span><span class="uncovered1"><a name="line25" /> 25 end
</span><span class="inferred0"><a name="line26" /> 26 
</span><span class="inferred1"><a name="line27" /> 27 # :include: USAGE
</span><span class="inferred0"><a name="line28" /> 28 # :main: USAGE
</span><span class="inferred1"><a name="line29" /> 29 
</span><span class="marked0"><a name="line30" /> 30 module MetaGen #:nodoc:
</span><span class="inferred1"><a name="line31" /> 31 
</span><span class="inferred0"><a name="line32" /> 32   # define the method
</span><span class="marked1"><a name="line33" /> 33   def self.add_method(klass, meth_name, body, meth_rdoc)
</span><span class="marked0"><a name="line34" /> 34     code = &lt;&lt;-CODE
</span><span class="inferred1"><a name="line35" /> 35     # #{meth_rdoc}
</span><span class="inferred0"><a name="line36" /> 36     def #{meth_name.downcase}
</span><span class="inferred1"><a name="line37" /> 37       @#{meth_name}
</span><span class="inferred0"><a name="line38" /> 38     end
</span><span class="inferred1"><a name="line39" /> 39     
</span><span class="inferred0"><a name="line40" /> 40     def #{meth_name.downcase}=(value)
</span><span class="inferred1"><a name="line41" /> 41       @#{meth_name.downcase} = value
</span><span class="inferred0"><a name="line42" /> 42     end
</span><span class="inferred1"><a name="line43" /> 43 
</span><span class="inferred0"><a name="line44" /> 44     private
</span><span class="inferred1"><a name="line45" /> 45     def parse_#{meth_name.downcase}
</span><span class="inferred0"><a name="line46" /> 46       begin
</span><span class="inferred1"><a name="line47" /> 47         #{body}
</span><span class="inferred0"><a name="line48" /> 48       rescue NoMethodError
</span><span class="inferred1"><a name="line49" /> 49         return nil
</span><span class="inferred0"><a name="line50" /> 50       end
</span><span class="inferred1"><a name="line51" /> 51     end
</span><span class="inferred0"><a name="line52" /> 52     CODE
</span><span class="inferred1"><a name="line53" /> 53     
</span><span class="marked0"><a name="line54" /> 54     klass.module_eval(code)
</span><span class="inferred1"><a name="line55" /> 55  
</span><span class="inferred0"><a name="line56" /> 56     # hook to write klass + name attrib to a file
</span><span class="marked1"><a name="line57" /> 57     if $META_RDOC
</span><span class="marked0"><a name="line58" /> 58       open($META_RDOC, 'a+') do |f|
</span><span class="marked1"><a name="line59" /> 59         f.puts(&quot;class #{klass}\n #{code}\n end&quot;)
</span><span class="inferred0"><a name="line60" /> 60       end
</span><span class="inferred1"><a name="line61" /> 61     end
</span><span class="inferred0"><a name="line62" /> 62     
</span><span class="inferred1"><a name="line63" /> 63   end
</span><span class="inferred0"><a name="line64" /> 64 
</span><span class="inferred1"><a name="line65" /> 65   # output in different formats
</span><span class="inferred0"><a name="line66" /> 66   # FIXME Only works in parse mode, not in generation mode. 
</span><span class="marked1"><a name="line67" /> 67   def self.add_output_format(klass, format, meth_rdoc)
</span><span class="marked0"><a name="line68" /> 68     xslt_path = &quot;'#{File.join( File.dirname(__FILE__), %Q{xspf2#{format}.xsl} )}'&quot;
</span><span class="marked1"><a name="line69" /> 69     code = &lt;&lt;-CODE
</span><span class="inferred0"><a name="line70" /> 70       # #{meth_rdoc}
</span><span class="inferred1"><a name="line71" /> 71       def to_#{format}
</span><span class="inferred0"><a name="line72" /> 72         xslt = XML::XSLT.new
</span><span class="inferred1"><a name="line73" /> 73         xslt.xml = self.to_xml
</span><span class="inferred0"><a name="line74" /> 74         xslt.xsl = REXML::Document.new( File.new( #{xslt_path} ) )
</span><span class="inferred1"><a name="line75" /> 75         xslt.serve
</span><span class="inferred0"><a name="line76" /> 76       end
</span><span class="inferred1"><a name="line77" /> 77     CODE
</span><span class="inferred0"><a name="line78" /> 78     
</span><span class="marked1"><a name="line79" /> 79     klass.module_eval(code)
</span><span class="inferred0"><a name="line80" /> 80    
</span><span class="marked1"><a name="line81" /> 81     if $META_RDOC
</span><span class="marked0"><a name="line82" /> 82       open($META_RDOC, 'a+') do |f|
</span><span class="marked1"><a name="line83" /> 83         f.puts(&quot;class #{klass}\n #{code}\n end&quot;)
</span><span class="inferred0"><a name="line84" /> 84       end
</span><span class="inferred1"><a name="line85" /> 85     end
</span><span class="inferred0"><a name="line86" /> 86 
</span><span class="inferred1"><a name="line87" /> 87   end
</span><span class="inferred0"><a name="line88" /> 88   
</span><span class="inferred1"><a name="line89" /> 89 end
</span><span class="inferred0"><a name="line90" /> 90 
</span><span class="marked1"><a name="line91" /> 91 class XSPF
</span><span class="inferred0"><a name="line92" /> 92 
</span><span class="marked1"><a name="line93" /> 93   attr_reader :xspf
</span><span class="inferred0"><a name="line94" /> 94 
</span><span class="inferred1"><a name="line95" /> 95   #:stopdoc:
</span><span class="marked0"><a name="line96" /> 96   ATTRIBUTES = %w{ version encoding }
</span><span class="marked1"><a name="line97" /> 97   VERSION_RDOC = 'Version for the XML document or _nil_ if not defined'
</span><span class="marked0"><a name="line98" /> 98   ENCODING_RDOC = 'Encoding of the XML document or _nil_ if not defined'
</span><span class="inferred1"><a name="line99" /> 99   
</span><span class="marked0"><a name="line100" />100   OUTPUT_FORMATS = %w{ m3u html smil rdf soundblox }
</span><span class="marked1"><a name="line101" />101   M3U_RDOC = 'Creates a .m3u playlist from the XSPF document. This method makes use of the official XSPF to M3U XSLT transformation by Lucas Gonze.'
</span><span class="marked0"><a name="line102" />102   HTML_RDOC = 'Outputs the playlist as an HTML page. This method makes use of the official XSPF to HTML XSLT transformation by Lucas Gonze.'
</span><span class="marked1"><a name="line103" />103   SMIL_RDOC = 'Creates a .smil playlist from the XSPF document. This method makes use of the official XSPF to SMIL XSLT transformation by Lucas Gonze.'
</span><span class="marked0"><a name="line104" />104   SOUNDBLOX_RDOC = 'Creates a SoundBlox playlist from the XSPF document. This method makes use of the official XSPF to SoundBlox XSLT tranformation by Lucas Gonze.'
</span><span class="marked1"><a name="line105" />105   RDF_RDOC = 'Creates a RDF feed from the XSPF document. This method makes use of the XSPF to RDF XSLT transformation by Libby Miller.'
</span><span class="inferred0"><a name="line106" />106 
</span><span class="marked1"><a name="line107" />107   ATTRIBUTES.each do |attrib|
</span><span class="marked0"><a name="line108" />108     MetaGen.add_method(self, attrib, &quot;@xspf.#{attrib}&quot;, eval(attrib.upcase + '_RDOC').to_s )
</span><span class="inferred1"><a name="line109" />109   end
</span><span class="inferred0"><a name="line110" />110 
</span><span class="marked1"><a name="line111" />111   OUTPUT_FORMATS.each do |format|
</span><span class="marked0"><a name="line112" />112     MetaGen.add_output_format(self, format, eval(format.upcase + '_RDOC').to_s )
</span><span class="inferred1"><a name="line113" />113   end
</span><span class="inferred0"><a name="line114" />114 
</span><span class="inferred1"><a name="line115" />115   #:startdoc:
</span><span class="inferred0"><a name="line116" />116   
</span><span class="inferred1"><a name="line117" />117   # Creates a XSPF object from a file or string (parse mode) or from a hash or nil (generation mode).
</span><span class="inferred0"><a name="line118" />118   #
</span><span class="inferred1"><a name="line119" />119   # Possible keys in the hash: :version, :encoding
</span><span class="marked0"><a name="line120" />120   def initialize(source = nil)
</span><span class="marked1"><a name="line121" />121     if ( source.nil? || source.instance_of?(Hash) ) then
</span><span class="marked0"><a name="line122" />122         @version = if source.nil? || !source.has_key?(:version)
</span><span class="marked1"><a name="line123" />123                      '1.0'
</span><span class="inferred0"><a name="line124" />124                    else
</span><span class="marked1"><a name="line125" />125                      source[:version]
</span><span class="inferred0"><a name="line126" />126                    end
</span><span class="marked1"><a name="line127" />127         @encoding = if source.nil? || !source.has_key?(:encoding)
</span><span class="marked0"><a name="line128" />128                       'UTF-8'
</span><span class="inferred1"><a name="line129" />129                     else
</span><span class="marked0"><a name="line130" />130                       source[:encoding]
</span><span class="inferred1"><a name="line131" />131                     end
</span><span class="marked0"><a name="line132" />132         @playlist = nil
</span><span class="marked1"><a name="line133" />133         @playlist = if !source.nil? &amp;&amp; source.has_key?(:playlist) then
</span><span class="marked0"><a name="line134" />134                         if source[:playlist].instance_of?(XSPF::Playlist)
</span><span class="marked1"><a name="line135" />135                             source[:playlist]
</span><span class="inferred0"><a name="line136" />136                         else
</span><span class="marked1"><a name="line137" />137                           raise(TypeError, 'You must pass a file/string (parsing mode) or a hash/nothing (generator mode) as argument to XSPF#new')
</span><span class="inferred0"><a name="line138" />138                         end
</span><span class="inferred1"><a name="line139" />139                     end
</span><span class="inferred0"><a name="line140" />140 
</span><span class="marked1"><a name="line141" />141     elsif ( source.instance_of?(File) || source.instance_of?(String) ) then
</span><span class="marked0"><a name="line142" />142         @xspf = REXML::Document.new(source)
</span><span class="marked1"><a name="line143" />143         ATTRIBUTES.each do |attrib|
</span><span class="marked0"><a name="line144" />144           eval('@' + attrib + '= parse_' + attrib)
</span><span class="inferred1"><a name="line145" />145         end
</span><span class="inferred0"><a name="line146" />146 
</span><span class="marked1"><a name="line147" />147         @playlist = XSPF::Playlist.new(self)
</span><span class="inferred0"><a name="line148" />148         
</span><span class="inferred1"><a name="line149" />149     else
</span><span class="marked0"><a name="line150" />150       raise(TypeError, 'You must pass a file/string (parsing mode) or a hash/nothing (generator mode) as argument to XSPF#new')
</span><span class="inferred1"><a name="line151" />151     end
</span><span class="marked0"><a name="line152" />152   end
</span><span class="inferred1"><a name="line153" />153 
</span><span class="inferred0"><a name="line154" />154   # A XSPF::Playlist object
</span><span class="marked1"><a name="line155" />155   def playlist
</span><span class="marked0"><a name="line156" />156     @playlist
</span><span class="marked1"><a name="line157" />157   end
</span><span class="inferred0"><a name="line158" />158 
</span><span class="marked1"><a name="line159" />159   def playlist=(value)
</span><span class="marked0"><a name="line160" />160     raise(TypeError, 'The playlist must be an instance of XSPF::Playlist') unless value.instance_of?(XSPF::Playlist)
</span><span class="marked1"><a name="line161" />161     @playlist = value
</span><span class="inferred0"><a name="line162" />162   end
</span><span class="inferred1"><a name="line163" />163 
</span><span class="inferred0"><a name="line164" />164   # Exports the XSPF object to XML
</span><span class="marked1"><a name="line165" />165   def to_xml
</span><span class="marked0"><a name="line166" />166     xml = REXML::Document.new
</span><span class="marked1"><a name="line167" />167     xml &lt;&lt; REXML::XMLDecl.new(@version, @encoding)
</span><span class="marked0"><a name="line168" />168     xml &lt;&lt; REXML::Document.new(@playlist.to_xml) unless @playlist.nil?
</span><span class="marked1"><a name="line169" />169     xml.to_s
</span><span class="inferred0"><a name="line170" />170   end
</span><span class="inferred1"><a name="line171" />171 
</span><span class="inferred0"><a name="line172" />172   # The &lt;playlist&gt; section of the XSPF document (outputs XML code). This method is only used while parsing.
</span><span class="marked1"><a name="line173" />173   protected
</span><span class="marked0"><a name="line174" />174   def playlist_xml
</span><span class="marked1"><a name="line175" />175     @xspf.root
</span><span class="marked0"><a name="line176" />176   end
</span><span class="inferred1"><a name="line177" />177 
</span><span class="inferred0"><a name="line178" />178 end
</span><span class="inferred1"><a name="line179" />179 
</span><span class="marked0"><a name="line180" />180 class XSPF::Playlist &lt; XSPF
</span><span class="inferred1"><a name="line181" />181 
</span><span class="marked0"><a name="line182" />182   attr_reader :playlist
</span><span class="inferred1"><a name="line183" />183 
</span><span class="inferred0"><a name="line184" />184   #:stopdoc:
</span><span class="marked1"><a name="line185" />185   ATTRIBUTES = %w{ xmlns version }
</span><span class="marked0"><a name="line186" />186   ELEMENTS = %w{ title creator annotation info location identifier image date license attribution extension }
</span><span class="marked1"><a name="line187" />187   ATTRIBUTE_AND_ELEMENT = %w{ link meta }
</span><span class="marked0"><a name="line188" />188   ATTRIBUTION_CHILD_ELEMENTS = %w{ location identifier }
</span><span class="marked1"><a name="line189" />189   EXTENSION_CHILD_ELEMENTS = %w{ application content }
</span><span class="inferred0"><a name="line190" />190   
</span><span class="marked1"><a name="line191" />191   XMLNS_RDOC = 'The XML namespace. It must be http://xspf.org/ns/0/ for a valid XSPF document.'
</span><span class="marked0"><a name="line192" />192   XMLNS_DEFAULT = 'http://xspf.org/ns/0/'
</span><span class="marked1"><a name="line193" />193   VERSION_RDOC = 'The XSPF version. It may be 0 or 1, although 1 is strongly advised.'
</span><span class="marked0"><a name="line194" />194   VERSION_DEFAULT = '1'
</span><span class="marked1"><a name="line195" />195   TITLE_RDOC = 'A human-readable title for the playlist. xspf:playlist elements MAY contain exactly one.'
</span><span class="marked0"><a name="line196" />196   CREATOR_RDOC = 'Human-readable name of the entity (author, authors, group, company, etc) that authored the playlist. XSPF::Playlist objects MAY contain exactly one.'
</span><span class="marked1"><a name="line197" />197   ANNOTATION_RDOC = 'A human-readable comment on the playlist. This is character data, not HTML, and it may not contain markup. XSPF::Playlist objects elements MAY contain exactly one.'
</span><span class="marked0"><a name="line198" />198   INFO_RDOC = 'URL of a web page to find out more about this playlist. Likely to be homepage of the author, and would be used to find out more about the author and to find more playlists by the author. XSPF::Playlist objects MAY contain exactly one.'
</span><span class="marked1"><a name="line199" />199   LOCATION_RDOC = 'Source URL for this playlist. XSPF::Playlist objects MAY contain exactly one.'
</span><span class="marked0"><a name="line200" />200   IDENTIFIER_RDOC = 'Canonical ID for this playlist. Likely to be a hash or other location-independent name. MUST be a legal URN. XSPF::Playlist objects MAY contain exactly one.'
</span><span class="marked1"><a name="line201" />201   IMAGE_RDOC = 'URL of an image to display if XSPF::Playlist#image return nil. XSPF::Playlist objects MAY contain exactly one.'
</span><span class="marked0"><a name="line202" />202   DATE_RDOC = 'Creation date (not last-modified date) of the playlist, formatted as a XML schema dateTime. XSPF::Playlist objects MAY contain exactly one.'
</span><span class="marked1"><a name="line203" />203   LICENSE_RDOC = 'URL of a resource that describes the license under which this playlist was released. XSPF::Playlist objects MAY contain zero or one license element.'
</span><span class="marked0"><a name="line204" />204   ATTRIBUTION_RDOC = 'An ordered list of URIs. The purpose is to satisfy licenses allowing modification but requiring attribution. If you modify such a playlist, move its XSPF::Playlist#location or XSPF::Playlist#identifier element to the top of the items in the XSPF::Playlist#attribution element. XSPF::Playlist objects MAY contain exactly one attribution element. Please note that currently XSPF for Ruby does not parse the contents of XSPF::Playlist#attribution.'
</span><span class="marked1"><a name="line205" />205   EXTENSION_RDOC = 'The extension element allows non-XSPF XML to be included in XSPF documents without breaking XSPF validation. The purpose is to allow nested XML, which the meta and link elements do not. XSPF::Playlist objects MAY contain zero or more extension elements but currently XSPF for Ruby returns only the first one.'
</span><span class="marked0"><a name="line206" />206   LINK_REL_RDOC = 'The link element allows non-XSPF web resources to be included in XSPF documents without breaking XSPF validation. A valid _link_ element has a _rel_ attribute and a _content_ element, obtained with XSPF::Playlist#link_rel and XSPF::Playlist#link_content respectively. XSPF::Playlist objects MAY contain zero or more link elements, but currently XSPF for Ruby returns only the first one.'
</span><span class="marked1"><a name="line207" />207   LINK_CONTENT_RDOC = 'The link element allows non-XSPF web resources to be included in XSPF documents without breaking XSPF validation. A valid _link_ element has a _rel_ attribute and a _content_ element, obtained with XSPF::Playlist#link_rel and XSPF::Playlist#link_content respectively. XSPF::Playlist objects MAY contain zero or more meta elements, but currently XSPF for Ruby returns only the first one.'
</span><span class="marked0"><a name="line208" />208   META_REL_RDOC = 'The meta element allows non-XSPF metadata to be included in XSPF documents without breaking XSPF validation. A valid _meta_ element has a _rel_ attribute and a _content_ element, obtained with XSPF::Playlist#meta_rel and XSPF::Playlist#meta_content respectively. XSPF::Playlist objects MAY contain zero or more meta elements, but currently XSPF for Ruby returns only the first one.'
</span><span class="marked1"><a name="line209" />209   META_CONTENT_RDOC = 'The meta element allows non-XSPF metadata to be included in XSPF documents without breaking XSPF validation. A valid _meta_ element has a _rel_ attribute and a _content_ element, obtained with XSPF::Playlist#meta_rel and XSPF::Playlist#meta_content respectively. XSPF::Playlist objects MAY contain zero or more meta elements, but currently XSPF for Ruby returns only the first one.'
</span><span class="inferred0"><a name="line210" />210   
</span><span class="inferred1"><a name="line211" />211 # FIXME Currently we only return the first &quot;link&quot;
</span><span class="inferred0"><a name="line212" />212 # FIXME Currently we only return the first &quot;meta&quot;
</span><span class="inferred1"><a name="line213" />213 # FIXME Currently we only return the first &quot;extension&quot;
</span><span class="inferred0"><a name="line214" />214 # TODO Parse &quot;attribution&quot;
</span><span class="inferred1"><a name="line215" />215 # TODO Parse &quot;extension&quot;
</span><span class="inferred0"><a name="line216" />216 
</span><span class="inferred1"><a name="line217" />217   # Returns the value of the attribute or nil if the attribute is not present
</span><span class="marked0"><a name="line218" />218   ATTRIBUTES.each do |attrib|
</span><span class="marked1"><a name="line219" />219     MetaGen.add_method( self, attrib, &quot;@playlist.root.attributes['#{attrib}']&quot;, eval(attrib.upcase + '_RDOC').to_s )
</span><span class="inferred0"><a name="line220" />220   end
</span><span class="inferred1"><a name="line221" />221 
</span><span class="marked0"><a name="line222" />222   ELEMENTS.each do |element|
</span><span class="marked1"><a name="line223" />223     MetaGen.add_method( self, element, &quot;@playlist.elements['#{element}'].text&quot;, eval(element.upcase + '_RDOC').to_s )
</span><span class="inferred0"><a name="line224" />224   end
</span><span class="inferred1"><a name="line225" />225 
</span><span class="marked0"><a name="line226" />226   ATTRIBUTE_AND_ELEMENT.each do |ae|
</span><span class="marked1"><a name="line227" />227     MetaGen.add_method( self, &quot;#{ae}_content&quot;, &quot;@playlist.elements['#{ae}'].text&quot;, eval(ae.upcase + '_CONTENT_RDOC').to_s )
</span><span class="marked0"><a name="line228" />228     MetaGen.add_method( self, &quot;#{ae}_rel&quot;, &quot;@playlist.elements['#{ae}'].attributes['rel']&quot;, eval(ae.upcase + '_REL_RDOC').to_s )
</span><span class="inferred1"><a name="line229" />229   end
</span><span class="inferred0"><a name="line230" />230 
</span><span class="inferred1"><a name="line231" />231   #:startdoc:
</span><span class="inferred0"><a name="line232" />232   
</span><span class="inferred1"><a name="line233" />233   # Creates a XSPF::Playlist from a XSPF document (parse mode) or from a hash of values (generation mode)
</span><span class="inferred0"><a name="line234" />234   #
</span><span class="inferred1"><a name="line235" />235   # Possible keys in the hash: :xmlns, :version, :title, :creator, :annotation, :info, :location, :identifier, :image, :date, :license, :attribution, :extension, :link_rel, :link_content, :meta_rel, :meta_content
</span><span class="marked0"><a name="line236" />236   def initialize(source = nil)
</span><span class="inferred1"><a name="line237" />237 
</span><span class="marked0"><a name="line238" />238     if ( source.instance_of?(Hash) || source.nil? ) then
</span><span class="inferred1"><a name="line239" />239 
</span><span class="marked0"><a name="line240" />240       ATTRIBUTES.each do |attrib|
</span><span class="marked1"><a name="line241" />241         add_instance_variable(source, attrib)
</span><span class="inferred0"><a name="line242" />242       end
</span><span class="inferred1"><a name="line243" />243 
</span><span class="marked0"><a name="line244" />244       ELEMENTS.each do |element|
</span><span class="marked1"><a name="line245" />245         add_instance_variable(source, element)
</span><span class="inferred0"><a name="line246" />246       end
</span><span class="inferred1"><a name="line247" />247 
</span><span class="marked0"><a name="line248" />248       ATTRIBUTE_AND_ELEMENT.each do |ae|
</span><span class="marked1"><a name="line249" />249         add_instance_variable(source, &quot;#{ae}_content&quot; )
</span><span class="marked0"><a name="line250" />250         add_instance_variable(source, &quot;#{ae}_rel&quot; )
</span><span class="inferred1"><a name="line251" />251       end
</span><span class="inferred0"><a name="line252" />252 
</span><span class="marked1"><a name="line253" />253       @tracklist = if ( !source.nil? &amp;&amp; source.has_key?(:tracklist) &amp;&amp; source[:tracklist].instance_of?(XSPF::Tracklist) )
</span><span class="marked0"><a name="line254" />254                       source[:tracklist]
</span><span class="inferred1"><a name="line255" />255                     else
</span><span class="marked0"><a name="line256" />256                       nil
</span><span class="inferred1"><a name="line257" />257                     end
</span><span class="inferred0"><a name="line258" />258 
</span><span class="marked1"><a name="line259" />259     elsif source.instance_of?(XSPF) then
</span><span class="inferred0"><a name="line260" />260 
</span><span class="marked1"><a name="line261" />261       @playlist = source.playlist_xml
</span><span class="inferred0"><a name="line262" />262 
</span><span class="marked1"><a name="line263" />263       ATTRIBUTES.each do |attrib|
</span><span class="marked0"><a name="line264" />264         eval('@' + attrib.downcase + '= parse_' + attrib.downcase)
</span><span class="inferred1"><a name="line265" />265       end
</span><span class="inferred0"><a name="line266" />266   
</span><span class="marked1"><a name="line267" />267       ELEMENTS.each do |element|
</span><span class="marked0"><a name="line268" />268         eval('@' + element.downcase + '= parse_' + element.downcase)
</span><span class="inferred1"><a name="line269" />269       end
</span><span class="inferred0"><a name="line270" />270 
</span><span class="marked1"><a name="line271" />271       ATTRIBUTE_AND_ELEMENT.each do |ae|
</span><span class="marked0"><a name="line272" />272         eval('@' + ae.downcase + '_content = parse_' + ae.downcase + '_content')
</span><span class="marked1"><a name="line273" />273         eval('@' + ae.downcase + '_rel = parse_' + ae.downcase + '_rel')
</span><span class="inferred0"><a name="line274" />274       end
</span><span class="inferred1"><a name="line275" />275 
</span><span class="marked0"><a name="line276" />276       @tracklist = XSPF::Tracklist.new(self)
</span><span class="inferred1"><a name="line277" />277 
</span><span class="inferred0"><a name="line278" />278     else
</span><span class="marked1"><a name="line279" />279       raise(TypeError, 'You must pass a XSPF object (parsing mode) or a hash (generator mode) as argument to XSPF::Playlist#new')
</span><span class="inferred0"><a name="line280" />280     end
</span><span class="inferred1"><a name="line281" />281     
</span><span class="marked0"><a name="line282" />282   end
</span><span class="inferred1"><a name="line283" />283 
</span><span class="inferred0"><a name="line284" />284   # A XSPF::Tracklist object
</span><span class="marked1"><a name="line285" />285   def tracklist
</span><span class="marked0"><a name="line286" />286     @tracklist
</span><span class="marked1"><a name="line287" />287   end
</span><span class="inferred0"><a name="line288" />288 
</span><span class="marked1"><a name="line289" />289   def tracklist=(value)
</span><span class="marked0"><a name="line290" />290     raise(TypeError, 'The tracklist must be an instance of XSPF::Tracklist') unless value.instance_of?(XSPF::Tracklist)
</span><span class="marked1"><a name="line291" />291     @tracklist = value
</span><span class="inferred0"><a name="line292" />292   end
</span><span class="inferred1"><a name="line293" />293 
</span><span class="marked0"><a name="line294" />294   alias :&lt;&lt; :tracklist=
</span><span class="inferred1"><a name="line295" />295 
</span><span class="inferred0"><a name="line296" />296   # Exports the XSPF::Playlist to XML (only the &lt;playlist&gt; section)
</span><span class="marked1"><a name="line297" />297   def to_xml
</span><span class="inferred0"><a name="line298" />298   
</span><span class="marked1"><a name="line299" />299     xml = REXML::Element.new('playlist')
</span><span class="inferred0"><a name="line300" />300 
</span><span class="marked1"><a name="line301" />301     ATTRIBUTES.each do |attrib|
</span><span class="inferred0"><a name="line302" />302       # TODO Sure there is a nicer way to do evaluate this condition...
</span><span class="marked1"><a name="line303" />303       unless eval('@' + attrib.downcase + '.nil?')
</span><span class="marked0"><a name="line304" />304         xml.attributes[attrib] = eval('@' + attrib.downcase)
</span><span class="inferred1"><a name="line305" />305       end 
</span><span class="inferred0"><a name="line306" />306     end
</span><span class="inferred1"><a name="line307" />307     
</span><span class="marked0"><a name="line308" />308     ELEMENTS.each do |element|
</span><span class="inferred1"><a name="line309" />309       # TODO Sure there is a nicer way to do evaluate this condition...
</span><span class="marked0"><a name="line310" />310       unless eval('@' + element.downcase + '.nil?')
</span><span class="marked1"><a name="line311" />311         el = REXML::Element.new(element)
</span><span class="marked0"><a name="line312" />312         el.add_text( eval('@' + element.downcase) )
</span><span class="marked1"><a name="line313" />313         xml.add_element(el)
</span><span class="inferred0"><a name="line314" />314       end 
</span><span class="inferred1"><a name="line315" />315     end
</span><span class="inferred0"><a name="line316" />316 
</span><span class="marked1"><a name="line317" />317     ATTRIBUTE_AND_ELEMENT.each do |ae|
</span><span class="inferred0"><a name="line318" />318       # TODO Sure there is a nicer way to do evaluate this condition...
</span><span class="marked1"><a name="line319" />319       unless eval('@' + ae.downcase + '_rel.nil? &amp;&amp; @'+ ae.downcase + '_content.nil?')
</span><span class="marked0"><a name="line320" />320         el = REXML::Element.new(ae.downcase)
</span><span class="marked1"><a name="line321" />321         el.add_attribute('rel', eval('@' + ae.downcase + '_rel') )
</span><span class="marked0"><a name="line322" />322         el.add_text( eval('@' + ae.downcase + '_content') )
</span><span class="marked1"><a name="line323" />323         xml.add_element(el)
</span><span class="inferred0"><a name="line324" />324       end 
</span><span class="inferred1"><a name="line325" />325     end
</span><span class="inferred0"><a name="line326" />326 
</span><span class="marked1"><a name="line327" />327     xml &lt;&lt; REXML::Document.new(@tracklist.to_xml)
</span><span class="inferred0"><a name="line328" />328     
</span><span class="marked1"><a name="line329" />329     xml.to_s
</span><span class="inferred0"><a name="line330" />330   
</span><span class="inferred1"><a name="line331" />331   end
</span><span class="inferred0"><a name="line332" />332   
</span><span class="inferred1"><a name="line333" />333   # The &lt;trackList&gt; section of the XSPF document (outputs XML code). This method is only used while parsing.
</span><span class="marked0"><a name="line334" />334   protected
</span><span class="marked1"><a name="line335" />335   def tracklist_xml  
</span><span class="marked0"><a name="line336" />336     @playlist.elements['trackList']
</span><span class="marked1"><a name="line337" />337   end
</span><span class="inferred0"><a name="line338" />338 
</span><span class="marked1"><a name="line339" />339   private
</span><span class="marked0"><a name="line340" />340   def add_instance_variable(hash, var)
</span><span class="inferred1"><a name="line341" />341 
</span><span class="marked0"><a name="line342" />342     if !hash.nil? &amp;&amp; hash.has_key?(var.downcase.to_sym)
</span><span class="marked1"><a name="line343" />343       eval('@' + var.downcase + ' = \'' + hash[var.downcase.to_sym] + '\'')
</span><span class="inferred0"><a name="line344" />344     else
</span><span class="marked1"><a name="line345" />345       eval('@' + var.downcase + ' = defined?(' + var.upcase + '_DEFAULT) ? ' + var.upcase + '_DEFAULT : nil')
</span><span class="inferred0"><a name="line346" />346     end
</span><span class="inferred1"><a name="line347" />347 
</span><span class="marked0"><a name="line348" />348   end
</span><span class="inferred1"><a name="line349" />349 
</span><span class="inferred0"><a name="line350" />350 end
</span><span class="inferred1"><a name="line351" />351 
</span><span class="marked0"><a name="line352" />352 class XSPF::Tracklist &lt; XSPF::Playlist
</span><span class="inferred1"><a name="line353" />353 
</span><span class="marked0"><a name="line354" />354   attr_reader :tracklist
</span><span class="inferred1"><a name="line355" />355 
</span><span class="inferred0"><a name="line356" />356   # Creates a XSPF::Tracklist from a XSPF::Playlist (parse mode) or without parameters (generation mode)
</span><span class="marked1"><a name="line357" />357   def initialize(playlist=nil)
</span><span class="marked0"><a name="line358" />358     if (playlist.instance_of?(Hash) || playlist.nil?) then
</span><span class="marked1"><a name="line359" />359       @tracklist = ''
</span><span class="marked0"><a name="line360" />360       @tracks = []
</span><span class="inferred1"><a name="line361" />361     else
</span><span class="marked0"><a name="line362" />362       @tracklist = playlist.tracklist_xml
</span><span class="marked1"><a name="line363" />363       @tracks = @tracklist.elements.collect { |track| XSPF::Track.new(track) }
</span><span class="inferred0"><a name="line364" />364     end
</span><span class="marked1"><a name="line365" />365   end
</span><span class="inferred0"><a name="line366" />366 
</span><span class="inferred1"><a name="line367" />367   # Returns an array XSPF::Track objects
</span><span class="marked0"><a name="line368" />368   def tracks
</span><span class="marked1"><a name="line369" />369     @tracks
</span><span class="marked0"><a name="line370" />370   end
</span><span class="inferred1"><a name="line371" />371 
</span><span class="inferred0"><a name="line372" />372   # Adds a new XSPF::Track to the XSPF::Tracklist
</span><span class="marked1"><a name="line373" />373   def &lt;&lt;(track)
</span><span class="marked0"><a name="line374" />374     @tracks &lt;&lt; track
</span><span class="marked1"><a name="line375" />375   end
</span><span class="inferred0"><a name="line376" />376 
</span><span class="inferred1"><a name="line377" />377   # Exports the XSPF::Tracklist to XML (only the &lt;trackList&gt; section)
</span><span class="marked0"><a name="line378" />378   def to_xml
</span><span class="marked1"><a name="line379" />379     xml = REXML::Element.new('trackList')
</span><span class="marked0"><a name="line380" />380     @tracks.each { |t| xml &lt;&lt; REXML::Document.new(t.to_xml) }
</span><span class="marked1"><a name="line381" />381     xml.to_s
</span><span class="inferred0"><a name="line382" />382   end
</span><span class="inferred1"><a name="line383" />383 
</span><span class="inferred0"><a name="line384" />384 end
</span><span class="inferred1"><a name="line385" />385 
</span><span class="marked0"><a name="line386" />386 class XSPF::Track
</span><span class="inferred1"><a name="line387" />387 
</span><span class="marked0"><a name="line388" />388   attr_reader :track
</span><span class="inferred1"><a name="line389" />389 
</span><span class="inferred0"><a name="line390" />390   #:stopdoc:
</span><span class="marked1"><a name="line391" />391   ELEMENTS = %w{ location identifier title creator annotation info image album trackNum duration extension }
</span><span class="marked0"><a name="line392" />392   ATTRIBUTE_AND_ELEMENT = %w{ link meta }
</span><span class="inferred1"><a name="line393" />393   
</span><span class="marked0"><a name="line394" />394   LOCATION_RDOC = 'URL of resource to be rendered. Probably an audio resource, but MAY be any type of resource with a well-known duration, such as video, a SMIL document, or an XSPF document. The duration of the resource defined in this element defines the duration of rendering. XSPF::Track objects MAY contain zero or more location elements, but a user-agent MUST NOT render more than one of the named resources. Currently, XSPF for Ruby returns only the first location.'
</span><span class="marked1"><a name="line395" />395   IDENTIFIER_RDOC = 'Canonical ID for this resource. Likely to be a hash or other location-independent name, such as a MusicBrainz identifier or isbn URN (if there existed isbn numbers for audio). MUST be a legal URN. XSPF::Track objects elements MAY contain zero or more identifier elements, but currently XSPF for Ruby returns only the first one.'
</span><span class="marked0"><a name="line396" />396   TITLE_RDOC = 'Human-readable name of the track that authored the resource which defines the duration of track rendering. This value is primarily for fuzzy lookups, though a user-agent may display it. XSPF::Track objects MAY contain exactly one.'
</span><span class="marked1"><a name="line397" />397   CREATOR_RDOC = 'Human-readable name of the entity (author, authors, group, company, etc) that authored the resource which defines the duration of track rendering. This value is primarily for fuzzy lookups, though a user-agent may display it. XSPF::Track objects MAY contain exactly one.'
</span><span class="marked0"><a name="line398" />398   ANNOTATION_RDOC = 'A human-readable comment on the track. This is character data, not HTML, and it may not contain markup. XSPF::Track objects MAY contain exactly one.'
</span><span class="marked1"><a name="line399" />399   INFO_RDOC = 'URL of a place where this resource can be bought or more info can be found.'
</span><span class="marked0"><a name="line400" />400   IMAGE_RDOC = 'URL of an image to display for the duration of the track. XSPF::Track objects MAY contain exactly one.'
</span><span class="marked1"><a name="line401" />401   ALBUM_RDOC = 'Human-readable name of the collection from which the resource which defines the duration of track rendering comes. For a song originally published as a part of a CD or LP, this would be the title of the original release. This value is primarily for fuzzy lookups, though a user-agent may display it. XSPF::Track objects MAY contain exactly one.'
</span><span class="marked0"><a name="line402" />402   TRACKNUM_RDOC = 'Integer with value greater than zero giving the ordinal position of the media on the XSPF::Track#album. This value is primarily for fuzzy lookups, though a user-agent may display it. XSPF::Track objects MAY contain exactly one. It MUST be a valid XML Schema nonNegativeInteger.'
</span><span class="marked1"><a name="line403" />403   DURATION_RDOC = 'The time to render a resource, in milliseconds. It MUST be a valid XML Schema nonNegativeInteger. This value is only a hint -- different XSPF generators will generate slightly different values. A user-agent MUST NOT use this value to determine the rendering duration, since the data will likely be low quality. XSPF::Track objects MAY contain exactly one duration element.'
</span><span class="marked0"><a name="line404" />404   EXTENSION_RDOC = 'The extension element allows non-XSPF XML to be included in XSPF documents without breaking XSPF validation. The purpose is to allow nested XML, which the meta and link elements do not. XSPF::Track objects MAY contain zero or more extension elements, but currently XSPF for Ruby returns only the first one.'
</span><span class="marked1"><a name="line405" />405   LINK_REL_RDOC = 'The link element allows non-XSPF web resources to be included in XSPF documents without breaking XSPF validation. A valid _link_ element has a _rel_ attribute and a _content_ element, obtained with XSPF::Track#link_rel and XSPF::Track#link_content respectively. XSPF::Track objects MAY contain zero or more link elements, but currently XSPF for Ruby returns only the first one.'
</span><span class="marked0"><a name="line406" />406   LINK_CONTENT_RDOC = 'The link element allows non-XSPF web resources to be included in XSPF documents without breaking XSPF validation. A valid _link_ element has a _rel_ attribute and a _content_ element, obtained with XSPF::Track#link_rel and XSPF::Track#link_content respectively. XSPF::Track objects MAY contain zero or more meta elements, but currently XSPF for Ruby returns only the first one.'
</span><span class="marked1"><a name="line407" />407   META_REL_RDOC = 'The meta element allows non-XSPF metadata to be included in XSPF documents without breaking XSPF validation. A valid _meta_ element has a _rel_ attribute and a _content_ element, obtained with XSPF::Track#meta_rel and XSPF::Track#meta_content respectively. XSPF::Track objects MAY contain zero or more meta elements, but currently XSPF for Ruby returns only the first one.'
</span><span class="marked0"><a name="line408" />408   META_CONTENT_RDOC = 'The meta element allows non-XSPF metadata to be included in XSPF documents without breaking XSPF validation. A valid _meta_ element has a _rel_ attribute and a _content_ element, obtained with XSPF::Track#meta_rel and XSPF::Track#meta_content respectively. XSPF::Track objects MAY contain zero or more meta elements, but currently XSPF for Ruby returns only the first one.'
</span><span class="inferred1"><a name="line409" />409 
</span><span class="marked0"><a name="line410" />410   ELEMENTS.each do |element|
</span><span class="marked1"><a name="line411" />411     MetaGen.add_method( self, element, &quot;@track.elements['#{element}'].text&quot;, eval(element.upcase + '_RDOC').to_s )
</span><span class="inferred0"><a name="line412" />412   end
</span><span class="inferred1"><a name="line413" />413 
</span><span class="marked0"><a name="line414" />414   ATTRIBUTE_AND_ELEMENT.each do |ae|
</span><span class="marked1"><a name="line415" />415     MetaGen.add_method( self, &quot;#{ae}_content&quot;, &quot;@track.elements['#{ae}'].text&quot;, eval(ae.upcase + '_CONTENT_RDOC').to_s )
</span><span class="marked0"><a name="line416" />416     MetaGen.add_method( self, &quot;#{ae}_rel&quot;, &quot;@track.elements['#{ae}'].attributes['rel']&quot;, eval(ae.upcase + '_REL_RDOC').to_s )
</span><span class="inferred1"><a name="line417" />417   end
</span><span class="inferred0"><a name="line418" />418 
</span><span class="inferred1"><a name="line419" />419   # :startdoc:
</span><span class="inferred0"><a name="line420" />420   
</span><span class="inferred1"><a name="line421" />421   # Creates a XSPF::Track object from a &lt;track&gt; section of the XSPF document or from a hash of values
</span><span class="inferred0"><a name="line422" />422   #
</span><span class="inferred1"><a name="line423" />423   # Possible keys in the hash in generation mode: :location, :identifier, :title, :creator, :annotation, :info, :image, :album, :tracknum, :duration, :extension, :link_rel, :link_content, :meta_rel, :meta_content)
</span><span class="marked0"><a name="line424" />424   def initialize(tr)
</span><span class="inferred1"><a name="line425" />425     
</span><span class="marked0"><a name="line426" />426     if tr.instance_of?(Hash)
</span><span class="inferred1"><a name="line427" />427 
</span><span class="marked0"><a name="line428" />428       ELEMENTS.each do |element|
</span><span class="marked1"><a name="line429" />429         add_instance_variable(tr, element.downcase)
</span><span class="inferred0"><a name="line430" />430       end
</span><span class="inferred1"><a name="line431" />431 
</span><span class="marked0"><a name="line432" />432       ATTRIBUTE_AND_ELEMENT.each do |ae|
</span><span class="marked1"><a name="line433" />433         add_instance_variable(tr, &quot;#{ae.downcase}_content&quot; )
</span><span class="marked0"><a name="line434" />434         add_instance_variable(tr, &quot;#{ae.downcase}_rel&quot; )
</span><span class="inferred1"><a name="line435" />435       end
</span><span class="inferred0"><a name="line436" />436       
</span><span class="inferred1"><a name="line437" />437     else
</span><span class="marked0"><a name="line438" />438       @track = tr
</span><span class="inferred1"><a name="line439" />439 
</span><span class="marked0"><a name="line440" />440       ELEMENTS.each do |element|
</span><span class="marked1"><a name="line441" />441         eval('@' + element.downcase + '= parse_' + element.downcase)
</span><span class="inferred0"><a name="line442" />442       end
</span><span class="inferred1"><a name="line443" />443 
</span><span class="marked0"><a name="line444" />444       ATTRIBUTE_AND_ELEMENT.each do |ae|
</span><span class="marked1"><a name="line445" />445         eval('@' + ae.downcase + '_content = parse_' + ae.downcase + '_content')
</span><span class="marked0"><a name="line446" />446         eval('@' + ae.downcase + '_rel = parse_' + ae.downcase + '_rel')
</span><span class="inferred1"><a name="line447" />447       end
</span><span class="inferred0"><a name="line448" />448     end
</span><span class="inferred1"><a name="line449" />449     
</span><span class="marked0"><a name="line450" />450   end
</span><span class="inferred1"><a name="line451" />451 
</span><span class="inferred0"><a name="line452" />452   # Exports the XSPF::Track to XML (only the &lt;track&gt; section)
</span><span class="marked1"><a name="line453" />453   def to_xml
</span><span class="inferred0"><a name="line454" />454 
</span><span class="marked1"><a name="line455" />455     xml = REXML::Element.new('track')
</span><span class="inferred0"><a name="line456" />456     
</span><span class="marked1"><a name="line457" />457     ELEMENTS.each do |element|
</span><span class="inferred0"><a name="line458" />458       # TODO Sure there is a nicer way to do evaluate this condition...
</span><span class="marked1"><a name="line459" />459       unless eval('@' + element.downcase + '.nil?')
</span><span class="marked0"><a name="line460" />460         el = REXML::Element.new(element)
</span><span class="marked1"><a name="line461" />461         el.add_text( eval('@' + element.downcase) )
</span><span class="marked0"><a name="line462" />462         xml.add_element(el)
</span><span class="inferred1"><a name="line463" />463       end 
</span><span class="inferred0"><a name="line464" />464     end
</span><span class="inferred1"><a name="line465" />465 
</span><span class="marked0"><a name="line466" />466     ATTRIBUTE_AND_ELEMENT.each do |ae|
</span><span class="inferred1"><a name="line467" />467       # TODO Sure there is a nicer way to do evaluate this condition...
</span><span class="marked0"><a name="line468" />468       unless eval('@' + ae.downcase + '_rel.nil? &amp;&amp; @'+ ae.downcase + '_content.nil?')
</span><span class="marked1"><a name="line469" />469         el = REXML::Element.new(ae.downcase)
</span><span class="marked0"><a name="line470" />470         el.add_attribute('rel', eval('@' + ae.downcase + '_rel') )
</span><span class="marked1"><a name="line471" />471         el.add_text( eval('@' + ae.downcase + '_content') )
</span><span class="marked0"><a name="line472" />472         xml.add_element(el)
</span><span class="inferred1"><a name="line473" />473       end 
</span><span class="inferred0"><a name="line474" />474     end
</span><span class="inferred1"><a name="line475" />475 
</span><span class="marked0"><a name="line476" />476     xml.to_s
</span><span class="inferred1"><a name="line477" />477     
</span><span class="inferred0"><a name="line478" />478   end
</span><span class="inferred1"><a name="line479" />479   
</span><span class="marked0"><a name="line480" />480   private
</span><span class="marked1"><a name="line481" />481   def add_instance_variable(hash, var)
</span><span class="inferred0"><a name="line482" />482     
</span><span class="marked1"><a name="line483" />483     if hash.has_key?(var.downcase.to_sym)
</span><span class="marked0"><a name="line484" />484       eval('@' + var.downcase + ' = \'' + hash[var.downcase.to_sym] + '\'')
</span><span class="inferred1"><a name="line485" />485     else
</span><span class="marked0"><a name="line486" />486       eval('@' + var.downcase + ' = defined?(' + var.upcase + '_DEFAULT) ? ' + var.upcase + '_DEFAULT : nil')
</span><span class="inferred1"><a name="line487" />487     end
</span><span class="inferred0"><a name="line488" />488   
</span><span class="marked1"><a name="line489" />489   end
</span><span class="inferred0"><a name="line490" />490 
</span><span class="inferred1"><a name="line491" />491 end
</span></pre><hr />    <p>Generated using the <a href='http://eigenclass.org/hiki.rb?rcov'>rcov code coverage analysis tool for Ruby</a> version 0.8.0.</p><p>
          <a href='http://validator.w3.org/check/referer'>
            <img src='http://www.w3.org/Icons/valid-xhtml10' height='31' alt='Valid XHTML 1.0!' width='88' />
          </a>
          <a href='http://jigsaw.w3.org/css-validator/check/referer'>
            <img src='http://jigsaw.w3.org/css-validator/images/vcss' alt='Valid CSS!' style='border:0;width:88px;height:31px' />
          </a>
        </p>
      </body>
    </html>
